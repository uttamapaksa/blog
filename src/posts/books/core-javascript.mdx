---
id: 1
title: "코어 자바스크립트 (저자: 정재남)"
datetime: "2024-11-18"
category:
  title: "Development"
  href: "#"
thumbnail: "https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791158391720.jpg"
source: "https://product.kyobobook.co.kr/detail/S000001766397"
summary: "자바스크립트의 핵심 개념과 동작 원리를 다룬 책이다. 데이터 타입, 실행 컨텍스트, this, 콜백 함수, 클로저, 프로토타입 등의 주요 주제들을 정리한다."
---

## 1장. Data Type
#### 1.1. 데이터 타입 종류
Primitive type: Number, String, Boolean, null, undefined, Symbol  
Reference type: Array, Function, Date, ReqExp, Map, WeakMap, Set, WeakSet
#### 1.2. 데이터 타입에 관한 배경지식
자바스크립트는 정수형이든 소수형이든 모두 64비트(8바이트) 부동소수점 형식(부호 1비트 + 지수부 11비트 + 가수부 52비트)으로 표현되어 형변환이 비교적 자유롭다. 메모리 주솟값을 식별자로 구분한다.
#### 1.3. 변수 선언과 데이터 할당
변수 a를 선언한다는 것은 변경 가능한 데이터를 담을 수 있는 메모리 공간(1001)을 확보하고 식별자를 a로 한다는 뜻이다. 변수 a에 값 b를 할당하면, 값 b를 담는 메모리 공간(5002)을 확보하고 그 공간에 b를 저장한 후에 그 공간의 주솟값(@5002)을 a공간(1001)에 대입한다.
#### 1.4. 기본형 데이터와 참조형 데이터
variable과 constant는 재할당 가능 여부로 구분되고, immuatable과 mutable은 값의 변경 가능 여부로 구분된다. 기본형 데이터는 한번 생성된 값을 변경할 수 없고, 없는 값은 새로 할당해서 해당 주소값을 참조한다. 참조형 데이터는 객체 내부의 프로퍼티가 또 다른 주소값을 참조하는 구조를 가진다. 이때, 두번째 이상의 참조값에 새로운 할당이 이루어지면 내용이 변경될 수 있기 때문에 가변적이다.
#### 1.5. 불변 객체
변경 전의 정보와 변경 후의 정보가 동시의 필요할 때는 원본을 보장할 불변 객체가 필요하다. 바로 아래 단계의 값만 복사하는 얕은 복사가 아닌 깊은 복사를 활용한다. 깊은 복사 함수, 라이브러리, JSON 문자열 변환 후 다시 객체로 변환하는 방법 등이 있다.
#### 1.6. undefined와 null
undefined는 값을 대입하지 않은 변수, 객체에 존재하지 않는 프로퍼티, 반환값이 없는 함수의 실행 결과 등에 부여된다. 비어있음을 뜻할 땐 명시적으로 null을 넣어준다. 동등 연산자(==)에선 둘이 같다. 

## 2장. Execution Context
#### 2.1. 실행 컨텍스트란?
실행 코드에 제공할 환경 정보들을 모아놓은 객체다. 코드들을 실행할 때 컨텍스트를 구성하고 콜 스택에 쌓아 환경과 순서를 보장한다. VariableEnvironment, LexicalEnvironment, ThisBinding으로 구성된다.
#### 2.2. VariableEnvironment
식별자들의 정보, 외부 환경 정보, 선언 시점의 스냅샷(초기화 단계에서 생성된 변수들의 초기 값)으로 구성된다.
#### 2.3. LexicalEnvironment
environmentRecord, outerEnvironmentReference로 구성된다. VariableEnvironment와 유사하지만 변경 사항이 저장된다.
1. **environmentRecord**  
현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 식별자 정보를 먼저 수집하는 호이스팅이 일어나는데 선언식 함수는 함수 정의 전체가, 변수와 주로 익명함수로 쓰이는 표현식 함수는 선언부만 호이스팅된다.  
2. **outerEnvironmentReference**  
스코프는 식별자의 유효 범위다. outerEnvironmentReference는 현재 스코프가 생성될 당시의 LexicalEnvironment를 참조한다. 이를 통해 스코프를 안에서 밖으로 찾아나가는 스코프 체인이 가능해진다.

## 3장. this
#### 3.1. 상황에 따라 달리지는 this
대부분의 객체 지향 언어에서 this는 클래스로 인스턴스 객체를 가리키지만, 자바스크립트에선 함수를 호출할 때(실행 컨텍스트 생성 시점)의 컨텍스트를 가리킨다.
1. **전역 공간**  
브라우저에서는 window, Node.js에서는 global이다. 전역 변수를 설정하면 전역 객체의 프로퍼티에도 할당된다. 자바스크립트 엔진은 변수를 선언하면 이를 실행 컨텍스트의 LexicalEnvironment 객체의 프로퍼티로도 저장하기 때문이다.
2. **메서드**  
객체의 메서드(obj.func)로서 호출할 때 this는 해당 객체를 가리킨다. 
3. **함수**  
함수로서 호출할 때는 호출 객체가 명시되지 않았기 때문에 this가 지정되지 않아 전역 객체를 가리킨다. 이를 피하기 위해 this binding이나 arrow function을 사용할 수 있다.
4. **콜백 함수**  
콜백 함수의 제어권을 가지는 함수가 this를 어떻게 지정했는지에 따라 달라진다.
5. **생성자 함수**  
생성된 인스턴스 객체를 가리킨다.
#### 3.2. 명시적으로 this를 바인딩하는 방법
명시적으로 바인딩하기 위해선 call, apply, bind 메서드를 사용하면 된다. 화살표 함수는 자신만의 this를 가지지 않고 작성된 위치에서의 상위 스코프의 this를 가리킨다. 콜백 함수를 인자로 받는 배열 메서드 중 일부도 두번째 인자(thisArg)로 this로 지정할 객체를 넘겨줄 수 있다.

## 4장. Callback Function
#### 4.1. 콜백 함수란?
콜백 함수는 다른 함수에 인자로 넘겨주는 함수이다. 다른 함수에 의해서 특정 시점에 다시 호출(call back)된다.
#### 4.2. 제어권
콜백 함수를 실행시키는 함수는 호출 시점, 인자, this에 대한 제어권을 갖는다.
#### 4.3. 콜백 함수는 함수다
객체의 메서드를 콜백 함수로 전달하더라도 실제로는 메서드가 아니라 독립된 함수로 전달된다.
#### 4.4. 콜백 함수 내부의 this에 다른 값 바인딩 하기
콜백 함수가 독립적으로 호출될 경우 this는 전역 개체가 된다. 내부 변수에 담거나 bind 함수를 써야 한다.
#### 4.5. 콜백 지옥과 비동기 제어
콜백 지옥은 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상이다. 비동기적인 작업을 수행하기 위해 이런 문제들이 발생한다. 기명 함수로의 변환, Promise, Generator, async/await 등의 해결 방법이 있다.

## 5장. Closure
#### 5.1. 클로저의 의미 및 원리 이해
클로저는 외부 함수의 실행 컨텍스트가 종료된 이후에도, 해당 함수의 변수에 접근할 수 있는 내부 함수를 말한다. 내부 함수의 outEnvironmentReference가 외부 함수의 LexicalEnvironment를 참조중이기 때문에 GC에 의해 사라지지 않는다.
#### 5.2. 클로저와 메모리 관리
메모리 누수를 막기 위해 클로저에 null이나 undefined를 할당해준다.
#### 5.3. 클로저 활용 사례
함수 내부에서 외부 데이터를 사용하거나, 접근 권한을 제어(정보 은닉)하거나 기존에 this로 하던 부분 적용 함수를 만들어 디바운스를 구현할 수 있다. 지연 실행이나 매개 변수를 일부만 변경하기 위한 커링 함수에도 쓰인다.

## 6장. Prototype
#### 6.1. 프로토타입의 개념 이해
클래스 기반 언어들과 다르게 자바스크립트는 프로토타입 기반 언어이다. 이를 프로토타입을 복제함으로써 상속의 효과를 얻는다. 자바스크립트에서 함수를 만들면 자동으로 prototype 객체가 프로퍼티로 생성된다. new 연산자로 Constructor(생성자 함수)를 호출하면 instance가 만들어지는데, 이 instance의 프로퍼티 [[prototype]]는 Constructor의 프로퍼티 prototype을 참조한다. [[prototype]]는 생략 가능하기 때문에 instance는 Constructor의 prototype에 있는 메서드나 프로퍼티를 [[prototype]]를 생략하고 자신의 것처럼 바로 호출할 수 있다. prototype엔 Constructor를 가리키는 constructor가 있다.
#### 6.2. 프로토타입 체인
어떤 데이터의 [[prototype]] 내부에 [[prototype]]이 연쇄적으로 이어진 것을 말한다. 자바스크립트 데이터는 기본형, 참조형 모두 체인 구조를 가지고 최상위에 Object.prototype를 가진다. 그래서 객체 전용 메서드는 모든 타입으로 접근 가능한 Object의 prototype에 있지 않고 static method로 만들고 인자로 instance를 넣는다.

## 7장. Class
#### 7.1. 클래스와 인스턴스의 개념 이해
클래스는 개체들의 공통 속성을 담고 있는 템플릿이고, 인스턴스는 클래스대로 만들어진 실존 개체를 말한다.
#### 7.2. 자바스크립트의 클래스
생성자 함수의 프로토타입 메서드는 일종의 상속(정확히는 프로토타입 체이닝 참조)이 되기 때문에 인스턴스에서 접근할 수 있다. 스태틱 메서드는 생성자 함수에서 접근해야 한다.
#### 7.3. 클래스 상속
ES6에서 클래스가 도입되기 전, ES5의 프로토타입 상속 방식은 클래스(정확히는 프로토타입)의 추상성이 떨어져 클래스에 있는 값이 인스턴스의 동작의 영향을 줄 수 있는 문제가 있었다. 더 정교한 상속 및 추상화를 위해 subClass의 프로퍼티 삭제, 빈 함수(Bridge), Object.create 등 여러 방법들이 도입되었다.
#### 7.4. ES6의 클래스 및 클래스 상속
ES6에서는 class, extends, super, constructor가 추가되어 추상화, 인스턴스 초기화, 상속, 상위 클래스 접근 등이 더 간단해졌다.
