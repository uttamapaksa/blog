---
id: 7
title: "혼자 공부하는 네트워크 (저자: 강민철)"
datetime: "2024-12-10"
category:
  title: "Development"
  href: "#"
thumbnail: "https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791169212144.jpg"
source: "https://product.kyobobook.co.kr/detail/S000212911507"
summary: "컴퓨터 네트워크의 필수적인 내용들을 담고 있다. 물리 계층, 데이터링크 계층, 네트워크 계층, 전송 계층, 응용 계층 등 네트워크 구조 핵심 내용을 단계적으로 학습하여 네트워크의 구조와 흐름을 이해할 수 있도록 돕는다."
---

## 1. 컴퓨터 네트워크 시작하기

### 1-1. 컴퓨터 네트워크를 알아야 하는 이유
많은 프로그램들이 하나의 장치 안에서 실행되기보다는 네트워크를 통해 다른 장치와 상호 작용하며 실행되는 경우가 많다. 즉, 많은 경우 네트워크로 실행된다. 개발 시의 배경 지식이나 유지 보수 시의 문제 해결을 위해 필요하다.
1. 컴퓨터 네트워크: 여러 개의 장치가 마치 그물처럼 서로 연결되어 정보를 주고받을 수 있는 통신망
2. 인터넷: 네트워크들을 연결한 네트워크의 네트워크

### 1-2. 네트워크 거시적으로 살펴보기
#### 기본구조: 통신망은 그래프 형태를 뛰고 있다. 노드가 간선을 통해 메시지를 주고 받는다.
1. 호스트: 가장자리에 위치한 노드. 우리 사용하는 대부분의 네트워크 기기가 호스트다. 서버와 클라이언트도 호스트다.
2. 네트워크 장비: 중간 노드. 호스트 간 주고받을 정보가 거쳐간다. 이더넷 허브, 스위치, 라우터, 공유기 등이 있다.
3. 통신 매체: 노드를 연결한는 간선. 유선 매채와 무선 매체가 있다.
4. 메시지: 노드가 주고받는 정보
#### 범위에 따른 분류
1. LAN(Local Area Network): 근거리 통신망. 가정, 기업, 학교 같은 한정된 공간의 네트워크
2. WAN(Wide Area Network): 먼 지역을 연결하는 광역 통신망. 인터넷이 이에 속한다. 인터넷에 접속하기 위한 WAN은 ISP(인터넷 서비스 제공사업자)가 관리한다. ISP는 WAN에 연결 가능한 회선을 임대하고, 우리는 ISP에 사용 요금을 낸다.
#### 메시지 교환 방식에 따른 분류
1. 회선 교환 방식: 호스트 간 메시지 전송로인 회선을 먼저 설정해야 통신할 수 있다. 회선 스위치를 통해 일대일 전송로를 확보한다. 전화망을 생각하면 된다. 경로를 점유중이면 다른 호스트가 못 쓰기 때문에 이용 효율이 떨어진다.  
2. 패킷 교환 방식: 메시지를 패킷이라는 작은 단위로 쪼개어 전송한다. 회선 교환 방식과 달리 두 호스트가 하나의 회선 경로를 점유하지 않기 때문에 네트워크 이용 요휼이 높다. 패킷 스위치(라우터, 스위치 등)를 통해 사전에 설정된 경로가 아닌 최적의 경로로 전송할 수 있다. 패킷은 페이로드(데이터)와 헤더(부가 정보)와 트레일러로 구성된다.
#### 송수신지 유형에 따른 분류
1. 유니 캐스트
2. 멀티 캐스트
3. 브로드 캐스트

### 1-3. 네트워크 미시적으로 살펴보기
#### 프로토콜
정보를 올바르게 주고받기 위해 노드 간의 합의된 규칙이나 방법. 언어가 같아야 소통할 수 있듯이 프로토콜이 같아야 통신할 수 있다. 보통 여러 프로토콜이 함께 사용된다. 저마다의 목적과 특징이 있다. IP, ARP, HTTP, TCP, UDP 등이 있다.
#### 네트워크 참조 모델
통신이 일어나는 정형화된 과정을 계층으로 나눈 구조. 택배 시에 보낼 물건을 확인하고, 포장하고, 택배 상자에 넣고, 택배 상자를 밀봉하고, 기사에게 보내는 것처럼 과정들을 나눈 것이다. 계층 별로 나누었기 때문에 네트워크의 구성과 설계가 용이하다. 또한 계층 별로 문제를 진단 및 해결하기 용이하다. '참조'를 위한 모델이기 때문에 실제 통신에서 꼭 그대로 대응되지는 않는다. 
  1. OSI 모델: 국제 표준화 기구에서 만든 네트워크 참조 모델
     1. 물리 계층: 1과 0으로 표현되는 비트 신호를 주고 받는 계층. 비트 데이터는 전기, 빛, 전파 등의 신호로 운반된다. 비트
     2. 데이터 링크 계층: 네트워크 내 주변 장치 간의 정보를 올바르게 주고받기 위한 계층. 프레임
     3. 네트워크 계층: 메시지를 수신자까지 전달하는 계층. IP 주소를 통해 수신지 호스트를 식별하고 경로를 설정한다. 패킷
     4. 전송 계층: 신뢰성 있고 안정성 있는 전송에 필요한 계층. 패킷의 흐름을 제어하고 오류를 점검한다. 세그먼트, 데이터그램
     5. 세션 계층: 호스트의 응용프로그램 연결 상태를 의미하는 세션을 관리하는 계층
     6. 표현 계층: 번역, 압축, 암호화 등을 하는 계층
     7. 응용 계층: 웹 페이지 제공 등 사용자를 위한 실질적인 네트워크 서비스가 제공되는 계층
  2. TCP/IP 모델: 이론적 설계를 위한 OSI와 달리 실용적 구현에 더 중점을 둔 모델. 데이터
     1. 네트워크 액세스 계층: 데이터 링크 계층과 유사. 이 책에서는 물리 계층과 데이터 링크 계층으로 나눠서 설명한다.
     2. 인터넷 계층: 네트워크 계층과 유사
     3. 전송 계층: 전송 계층과 유사
     4. 응용 계층: OSI의 세션, 표현, 응용 계층을 합친 것과 유사
#### 캡슐화와 역캡슐화
송신자 입장에선 응용 계층 -> 물리 계층으로 캡슐화해서 내려보낸다. 수신자 입장에선 반대로 물리 계층으로 온 것을 역캡슐화해서 응용 계층으로 올려보낸다.
1. 캡슐화encapsulation: 상위 계층으로 받은 패킷을 페이로드로 삼아 현재 프로토콜에 걸맞는 헤더를 붙인후 하위 계층으로 전달하는 것
2. 역캡슐화decapsulation: 각 계층에서 헤더를 제거하여 상위 계층으로 올려보내는 것
3. PDU(protocol data unit): 각 계층에서 송수신되는 메시지의 단위. 현재 프로토콜 헤더를 추가하면 현재 계층의 PDU가 된다. 물리 계층은 비트, 데이터 링크 계층은 프레임, 네트워크 계층은 패킷, 전송 계층은 세그먼트, 응용 표현 세션 계층은 데이터다. 여기서의 패킷은 패킷 교환 방식의 전송 단위 패킷과는 다른 것이다.
#### 트래픽과 네트워크 성능 지표
1. 트래픽: 실제 네트워크 내의 정보량. 트래픽이 몰린다는 것은 특정 시간 동안 처리해야 할 정보가 많음을 의미한다.
2. 처리율: 단위 시간 당 실제로 전송되는 정보량. bps(bit/s), Mbps, Gbps, pps 등
3. 대역폭: 단위 시간 동안 송수신할 수 있는 최대 정보량
4. 패킷 손실: 순간적으로 처리해야 할 패킷이 너무 많아지거나 예상치 못한 장애 등으로 패킷이 손실되는 것

## 2. 물리 계층과 데이터 링크 계층

### 2-1. 이더넷
현대의 유선 LAN 환경에서 가장 대중적으로 사용되는 기술, 프로토콜. 케이블을 통해 송수신하는 방법, 프레임의 형태 등이 정의된다. 전기전자공학자협회가 정한 IEEE 802.3이라는 이더넷 표준을 따른다.
#### 표기형태
1. [전송속도]BASE-[추가 특성]. 25GBASE-LR4
2. 전송 속도: 숫자만 표기되면 Mbps, G가 붙으면 Gbps
3. 추가 특성: 통신 매체의 특성. 전송 가능한 최대 거리, 물리 계층 인코딩 방식, 레인 수 등 다양한 특성을 명시할 수 있다.
#### 통신 매체 종류
1. C: 동축 케이블
2. T: 트위스타드 페어 케이블(구리 선)
3. S: 단파장 광섬유 케이블
4. L: 장파장 광섬유 케이블. 1000BASE-LX 케이블 = 1000Mbps 속도를 지원하는 장파장 광섬유 케이블
#### 이더넷 프레임
이더넷 네트워크에서 주고받는 프레임
1. 헤더: 프리앰블(이더넷 프레임의 시작을 알리는 필드), 수신지 MAC 주소(물리적 주소), 송신지 MAC주소, 타입(상위 프로토콜 이름) 혹은 길이(프레임 크기)로 구성된다.
2. 페이로드: 데이터
3. 트레일러: FCS(오류가 있는지 확인하기 위한 필드)

### 2-2. NIC와 케이블
#### NIC(Network Interface Controller)
호스트와 통신 매체(케이블)를 연결하고, MAC 주소가 부여되는 네트워크 장비. 전기나 빛 등 통신 매체의 다양한 신호를 호스트가 이해할 수 있도록 비트 데이터로 변환해준다. 즉, 호스트를 네트워크(LAN)에 연결하기 위한 하드웨어. 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드 등으로 불린다.
#### 케이블
물리 계층의 유선 통신 매체
#### 트위스티드 페어 케이블
구리 선으로 전기 신호를 주고 받는 통신 매체. 두 가닥씩 꼬여 있다.
1. 구성: 케이블 본체 + 커넥터(주로 RJ-45). 케이블 본체의 구리선은 노이즈를 막기 위해 실드로 차폐되어 있다.
2. 실드에 따른 분류. [외부실드]/[구리선 실드]
   1. U: 실드 없음. U/UTP(아무것도 감싸지 않은 케이블)
   2. S: 브레이드 실드 
   3. F: 포일 실드. SF/FTP(케이블 외부는 브레이드 실드와 포일 실드, 꼬인 각 구리 선 쌍은 포일 실드)
3. 카테고리에 따른 분류: Cat3, Cat5, Cat5e, Cat6, Cat7 등. 숫자가 높을수록 전송 속도가 빠르고 대역폭이 크다.
#### 광섬유 케이블
빛(광신호)을 이용해 정보를 주고받는 케이블. 전기 신호를 이용하는 케이블보다 전송 속도가 빠르고 노이즈도 적다.
1. 구성: 케이블 본체 + 커넥터(LC, SC, FC, ST). 케이블 본체에는 머리카락 같은 광섬유들이 있고, 광섬유는 빛이 흐르는 코어와 빛을 가두는 클래딩으로 구성된다.
2. 싱글 모드 광섬유 케이블SMF: 지름이 보통 8~10 나노미터로 손실이 적어 장거리 전송에 적합하다. 비용이 높다.
3. 멀티 모드 광섬유 케이블MMF: 지름이 보통 50~62.5 나노미터로 근거리 전송에 적합하다.

### 2-3. 허브
1. 개요: 물리 계층의 네트워크 장비. 여러 대의 호스트를 연결하는 장치이다. 리피터 허브, 이더넷 허브라고도 부른다. 커넥터를 꽂을 수 있는 포트가 있다.
2. 특징 1: 전달 받은 신호 그대로 송신지를 제외한 모든 포트에 내보낸다. 물리 계층엔 주소 개념이 없기 때문에 송수신지도 특정하지 못하기 때문이다. 데이터 링크 계층부터 판단하고 조작할 수 있다.
3. 특징 2: 반이중 모드로 통신한다. 송수인이 동시에 안 되는 1차선 도로와 같다. 동시에 되면 전이중 모드 통신이라고 한다.
4. 콜리전 도메인: 충돌 발생 가능 영역. 반이중 모드이기 때문에 여러 호스트가 동시에 송신하면 충돌이 발생한다. 호스트 전체가 콜리전 도메인이다.
5. CSMA/CD: 반이중 이더넷 네트워크의 충돌 방지 프로토콜. 현재 전송중인 것이 있는지 확인 후 전송하고, 그럼에도 충돌나면 송신 호스트는 다른 호스트들에게 잼 신호를 보낸 후 임의 시간 대기 후에 재전송한다.

### 2-4. 스위치
1. 개요: 데이터 링크 계층의 네트워크 장비. 여러 대의 호스트를 연결하는 장치이다. 2계층에서 사용한다고 해서 L2 스위치라고도 부른다.
2. 특징 1: MAC 주소 학습을 하기 때문에 특정 MAC 주소를 가진 호스트에만 프레임을 전달할 수 있다. MAC 주소 테이블에 포트와 MAC 주소가 매핑된다.
3. 특징 2: 전이중 모드 통신을 지원한다. 콜리전 도메인은 포트별로 한정된다. CSMA/CD가 필요 없으므로 대기 시간도 없어 성능이 좋다.
#### MAC 주소 학습
1. 초기학습: 송신지가 처음 신호를 보내면 스위치는 송신지의 MAC 주소와 포트를 학습한다.
2. 플러딩: 수신지 포트 번호를 모르기 때문에 모든 포트에 보낸다. 호스트들은 자기 것이 아니면 폐기하고, 맞다면 스위치에 응답 프레임을 전송한다. 이제 스위치는 송신지의 MAC 주소와 포트도 학습니다.
3. 필러팅과 포워딩: 필터링은 전달받은 프레임이 특정 포트로 가지 않게 차단하는 것, 포워딩은 전송될 포트로 프레임을 전송하는 것
4. 에이징: 특정 포트에서 일정 시간 동안 프레임을 전송받지 못했다면 해당 항목을 삭제하는 것
#### VLAN(Virtual LAN)
가상의 LAN을 만들어 한 대의 물리적 스위치를 여러 대의 스위치가 있는 것처럼 구획하는 방법. 모든 포트에 불필요한 트래픽이 가지 않게 해준다. 아예 포트 기반으로 나눠놓는 포트 기반 VLAN과 사전 설정된 주소에 따라 나누는 MAC 기반 VLAN이 있다. 포트가 모자라다면 트렁크 포트를 이용해 VLAN을 연결해 확장할 수 있다.

## 3. 네트워크 계층

### 3-1. LAN을 넘어서는 네트워크 계층
#### 데이터 링크 계층의 한계
1. 다른 네트워크까지의 도달 경로 파악이 어렵다. 물리 계층과 데이터 링크 계층은 LAN을 다루지만, LAN간의 연결 경로를 다루지는 않는다. LAN간의 최적 경로를 찾는 라우팅routung은 네트워크 계층의 장비가 있어야 한다. 
2. MAC 주소만으론 호스트들의 위치를 특정하기 어렵다. 현실적으로 모든 네트워크의 속한 모든 호스트의 MAC 주소를 서로 알고 있기란 불가능하다. 수신인(강민철) MAC 주소와 수신지(혼공아파트 102호) IP 주소를 모두 알아야 한다.
#### 인터넷 프로토콜(Internet Protocol)
1. 개요: 네트워크 계층의 가장 핵심적인 프로토콜이다. IP에는 IPv4, IPv6 두 가지 버전이 있다.
3. 기능 1: IP 주소 기능. IP 주소를 바탕으로 송수신 대상을 지정한다.
4. 기능 2: IP 단편화. 전송하려는 패킷의 크기가 MTU(최대 전송 단위)보다 클 경우 복수의 패킷으로 나눈다.
#### IPv4
1. 주소 형태: 4바이트(32비트)로 나타낸다. 0~255의 십진수 4비트가 총 4개 표시된다. 192.168.1.1. 8비트 한 묶음을 옥텟이라 한다.
2. 패킷 헤더: 프레임 페이로드에 들어있는 패킷 헤더와 패킷 페이로드의 주요 내용은 아래와 같다.
   1. 식별자
   2. 플래그: 3비트로 구성. 0(예약 비트) + DF(단편화 수행 금지 플래그) + MF(단편화 미종료 플래그)
   3. 단편화 오프셋: 초기 데이터에서 몇번째 떨어진 오프셋인지 확인
   4. TTL(Time To Live): 패킷의 남은 수명. 한 번 전달되는 홉마다 1씩 줄어서 0이 되면 폐기
   5. 프로토콜: 상위 계층의 프로토콜 명시
   6. 송신지 IP 주소와 수신지 IP 주소  
3. 패킷 페이로드: 데이터
#### IPv6
1. 주소 형태: 16바이트로 나타낸다. 0~65535의 십육진수 4비트가 총 8개 표시된다. 2001:0230:abcd:ffff:0000:0000:ffff:1111
2. 패킷 헤더
   1. 다음 헤더: 상위 계층 프로토콜이나 확장 헤더. 라우팅, 단편화, 암호화 등을 위한 확장 헤더가 있다.
   2. 홉 제한: 패킷의 남은 수명
   3. 송신지 IP 주소와 수신지 IP 주소
3. 패킷 페이로드: 데이터
#### ARP
같은 네트워크 내에서 IP 주소를 통해 MAC 주소를 알아내는 프로토콜. 만약 호스트A와 호스트B가 다른 네트워크에 있다면 호스트A -> ARP -> 라우터A -> ARP -> 라우터B -> ARP -> 호스트B 이렇게 여러 차례 ARP를 거쳐야 한다. 
1. ARP 요청: 네트워크 내의 모든 호스트에서 브로드캐스트 메시지를 보내는 ARP 패킷(3계층이니까 프레임 페이로드에 포함).
2. ARP 응답: 수신 대상이 아닌 호스트들은 자신의 IP가 아니라서 무시하고 대상 호스트가 자신의 MAC 주소를 담아 보내는 패킷
3. ARP 테이블 갱신: 1, 2단계가 완료되면 IP 주소와 MAC 주소를 테이블에 매핑하는 것
#### 경로 MTU 발견
전송할 수 있는 최대 MTU를 찾는 것. IP 단편화는 성능 저하 때문에 하지 않는 것이 좋아서 대개 늘 최대 MTU로 보낸다. DF 플래그를 설정해놓고 보내다가 MTU 크기 초과로 오류가 나면 데이터 크기를 줄이는 식으로 찾는다.

### 3-2. IP 주소
#### 네트워크 주소와 호스트 주소
IP 주소는 네트워크를 가리키는 네트워크 주소(네트워크 ID, 네트워크 식별자)와 호스트를 가리키는 호스트 주소(호스트 ID, 호스트 식별자)로 나뉜다.
#### 클래스풀 주소 체계 classful addressing
네트워크 크기에 따라서 IP 주소를 분류해서 관리하는 주소 체계. 첫번째 옥텟의 숫자를 보면 어느 클래스인지 구분할 수 있다. 네트워크 주소(호스트 주소가 전부 0)와 브로드캐스트 주소(호스트 주소가 전부 1) 이 2개는 예외 주소라서 활용할 수 없다.  
1. A 클래스: [네트워크 주소].[호스트 주소].[호스트 주소].[호스트 주소]. A클래스 네크워트 주소는 첫번째 비트가 0으로 시작하기 때문에 128(2^7)개의 주소를 가질 수 있다. 0.xxx.xxx.xxx ~ 127.xxx.xxx.xxx
2. B 클래스: [네트워크 주소].[네트워크 주소].[호스트 주소].[호스트 주소]. B클래스 네크워트 주소는 비트가 10으로 시작하기 때문에 65534(2^16)개의 주소를 가질 수 있다. 128.0.xxx.xxx ~ 191.255.xxx.xxx
3. C 클래스: [네트워크 주소].[네트워크 주소].[네트워크 주소].[호스트 주소]. C클래스 네크워트 주소는 비트가 110으로 시작하기 때문에 2097152(2^21)개의 주소를 가질 수 있다. 192.0.0.xxx ~ 223.255.255.xxx
#### 클래스리스 주소 체계 classless addressing
클래스 없이 임의로 네트워크 영역과 호스트 영역을 나누어서 효율적으로 IP 주소를 할당할 수 있는 주소 체계
1. 서브넷 마스크: IP 주소상에서 네트워크 주소는 1, 호스트 주소는 0으로 표기한 비트열. 이렇게 나누는 것을 서브네팅이라고 한다. 이것과 IP 주소를 비트 AND 연산하면 네트워크 주소가 나온다.
2. 서브넷 마스크 10진수 표기: A클래스라면 IP: 123.86.72.203 서브넷 마스크: 255.0.0.0. B클래스라면 IP: 156.23.53.1 서브넷 마스크: 255.255.0.0. 
3. 서브넷 마스크 CIDR 표기: A클래스라면 123.86.72.203/8, B클래스라면 156.23.53.1/16.
#### 공인 IP 주소와 사설 IP 주소
1. 공인 IP 주소: 전 세계에서 고유한 IP 주소
2. 사설 IP 주소: 사설 네트워크에서 사용하기 위한 IP. 10.0.0.0/8, 172.16.0.0/12(172.16~172.31), 192.168.0.0/16은 사설 IP로 간주하기로 약속되어있다. 다수의 사설 IP는 NAT(Network Address Translation)를 통해 공인 IP로 변환되어 소수의 공인 IP를 공유한다. 내부에선 사설 IP, 외부에는 공인 IP로 나간다.
#### 정적 IP 주소와 동적 IP 주소
1. 정적 할당: 호스트에 직접 수작업으로 IP 주소를 부여하는 방식. IP 주소, 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소를 직접 입력하면 해당 호스트는 고정된 주소를 가지게 된다. 기본 게이트웨이 주소는 네트워크 외부로 나가기 위한 기본적인 첫 번째 경로인데 보통 라우터를 가리킨다.
2. 동적 할당: 호스트에 IP 주소가 자동으로 동적으로 할당되는 방식. DHCP 프로토콜을 통해 DHCP 서버(보통은 라우터가 수행)가 호스트에서 IP 주소를 임대한다. IP주소가 사용되지 않을 때 회수되고 사용할 때는 새로 할당받거나 임대를 갱신한다.
   1. DHCP Discover: 클라이언트가 브로드캐스트로 DHCP 서버를 찾는 DHCP Discover 메시지(패킷)을 보낸다.
   2. DHCP Offer: 메시지를 받은 DHCP 서버는 클라이언트에게 IP 주소를 제안하는 DHCP Offer 메세지를 보낸다.
   3. DHCP Request: 클라이언트는 제안한 IP를 써도 되냐고 되묻는다.
   4. DHCP ACK: 클라이언트에게 최종 승인한다는 DHCP ACK 메시지를 보낸다.
#### 예약 주소
이 네트워크의 이 호스트 주소(0.0.0.0/8), 루프백 주소(로컬 호스트, 127.0.0.0/8), 사설 네트워크 주소(10.0.0.0/8 등) 테스트용 주소 등이 있다.

### 3-3. 라우팅
#### 라우터
네트워크 계층의 핵심 장비. 패킷의 최적 경로를 설정하고 패킷을 이동시킨다. 비슷한 장비로 L3 스위치가 있다. 가정 환경에서는 공유기가 라우터의 역할을 대신한다. 호스트나 라우터 간 이동 과정을 홉이라고 한다. 우리가 구글 검색을 하면 패킷은 많은 홉을 거치게 된다.
#### 라우팅 테이블
패킷의 최적 경로를 결정하기 위해 라우터는 라우팅 테이블을 참고한다. 최종 수신지 IP주소와 서브넷 마스크, 게이트웨이로 명시되기도 하는 다음 홉, 패킷을 내보낼 통로인 네트워크 인터페이스, 해당 경로 이동에 드는 비용이 메트릭 등의 정보가 명시되어 있다. 테이블에 없는 수신지 경로는 디폴트 라우트로 보내게 되는데, 라우터 주소인 기본 게이트웨이를 디폴트 라우트로 삼는다.
#### 정적 라우팅과 동적 라우팅
1. 정적 라우팅: 사용자가 수동으로 채워넣은 라우팅 테이블을 토대로 라우팅하는 방식
2. 동적 라우팅: 자동으로 라우팅 테이블 항목을 만들고 라우팅하는 방식. 라우터들이 라우팅 프로토콜을 통해 최적의 경로를 찾는다.
#### 라우팅 프로토콜
1. AS(Autonomous System): 동일한 라우팅 정책으로 운용되는 라우터들의 집합. AS 내에는 다수의 라우터가 있고 AS 외부와 통신할 때는 AS 경계 라우터(ASBR)를 이용한다.
2. IGP(Interior Gateway Protocol): AS 내부에서 수행되는 라우팅 프로토콜
   1. RIP: 거리 벡터(홉의 수)를 기반으로 최적 경로를 판단한다. 인접 라우터들끼리 주기적으로 라우팅 테이블을 갱신해서 참조한다.
   2. OSPF: 링크 상태(매트릭)를 기반으로 최적 경로를 판단한다. 네트워크 구성 변경 시에 링크 상태 데이터베이스를 갱신해서 참조한다
   3. EIGRP: 둘의 하이브리드인 라우팅 프로토콜
3. EGP(Exterior Gateway Protocol): AS 외부에서 수행되는 라우팅 프로토콜. 
   1. BGP: AS 간의 통신(eBGP)이 가능한 프로토콜. AS 내의 통신(iBGP)에도 쓸 수 있다. AS 내의 eBGP를 사용하는 피어peer라는 라우터를 통해 AS간 통신을 한다. 경로 상태(거쳐가는 AS의 수)를 기반으로 최적 경로를 판단한다. AS 관리 주체의 BGP 정책도 판단의 중요한 기준이 된다.

## 4. 전송 계층
네트워크 계층의 한계를 보완하고 응용 계층과의 연결점을 제공하는 계층이다.

### 4-1. 전송 계층 개요: IP의 한계와 포트
#### 신뢰할 수 없는 통신과 비연결형 통신
1. 한계: IP는 빠른 전송을 위해 신뢰와 연결을 보장하지 않는 비신뢰성, 비연결형 프로토콜이다.
1. 비신뢰성: 패킷이 제대로 전송되었다는 보장을 하지 않는다. 손상이든 중복이든 확인하지 않는다. 최선을 다해보겠지만 결과는 보장하지 않겠다는 최선형 전달이다.
2. 비연결형: 사전 연결 수립 작업 없이 패킷을 보내기만 한다.
#### 응용 계층과의 연결 다리, 포트
포트는 응용 계층의 애플리케이션 프로세스를 식별하는 정보이다. 수신지 호스트와 그 호스트의 특정 애플리케이션을 연결해준다. 이 점에서 전송 계층이 네트워크 계층과 응용 계층을 연결해준다고 할 수 있다. 192.168.0.15:8000
1. 잘 알려진 포트(well known port, system port): 0~1023번. 범용적으로 사용되는 애플리케이션 프로토콜이 사용하는 포트 번호. 20,21(FTP), 22(SSH), 23(TELNET), 53(DSN), 80(HTTP), 443(HTTPS).
2. 등록된 포트(registered port): 1024~49151번. 웰노운 만큼은 아니지만 잘 알려진 애플리케이션 프로토콜에 할당한다. 1194(OpenVPN), 1433(MS SQL Server), 3306(MySQL), 6379(Redis), 8080(HTTP 대체)
3. 동적 포트(사설 포트, 임시포트): 49152~64435번. 자유롭게 사용하는 포트. 물론 웰노운 포트나 등록된 포트도 권고 사항일 뿐 자유롭게 사용할 수 있다. 클라이언트 프로그램은 동적 포트 번호 중 임의로 할당되는 경우가 많다.
#### NAT
IP 변환 기술. 공인 IP와 사설 IP 간 IP 변환을 해준다.
1. NAT 테이블: 매핑된 네트워크 외부와 네트워크 내부 주소를 참고하여 변환한다.

| 네트워크 외부 | 네트워크 내부 |
| ------------ | ------------ |
| 1.2.3.4      | 192.168.0.5  |
| 1.2.3.5      | 192.168.0.6  |

2. NAPT(APT): 포트 기반의 NAT. 여러 사설 IP가 하나의 공인 IP를 공유하는 경우가 많기 때문에 공인 IP의 포트 별로 사설 IP를 나눠서 공인 IP 부족 문제를 해결할 수 있다. 1.2.3.4:6201, 192.168.0.5, 1.2.3.4:6202, 192.168.0.6

| 네트워크 외부 | 네트워크 내부 |
| ------------ | ------------ |
| 1.2.3.4:6201 | 192.168.0.5  |
| 1.2.3.4:6202 | 192.168.0.6  |

#### 포트포워딩 port forwarding
네트워크 내에서 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고 해당 IP 주소:포트 번호로 해당 호스트에게 패킷을 전달하는 기능. 네트워크 외부 호스트가 내부 호스트에게 접근하기 위해 쓰인다. 일반적으로 검색을 할 때는 클라이언트가 먼저 사설 IP 주소와 포트 번호와 함께 서버에게 요청하지만, 외부에서 먼저 요청을 시작하는 경우에는 미리 할당해놓고 그 포트로 접속할 수 있게 포트 포워딩이 필요하다.
#### ICMP(Internet Control Message Protocol)
IP 패킷의 전송 과정에 대한 피드백 메시지(문제에 대한 오류 보고, 네트워크상의 정보 제공)를 받기 위한 네트워크 계층의 프로토콜. ICMP 메시지는 타입과 코드로 구성되는데 정의된다. 수신지 도달 불가나 시간 초과, 네트워크 진단 및 테스트에 쓰인다. IP의 비신뢰성을 보완은 해주지만 신뢰성을 보장하려면 전송 계층 프로토콜이 필요하다.  

### 4-2. TCP(Transmission Control Protocol)
1. 개요: 신뢰할 수 있는 통신을 위한 연결형 프로토콜
2. MSS: TCP가 전송할 수 있는 최대 페이로드 크기. 섹헤더 크기는 제외한다.
3. TCP 세그먼트
   1. 송신지 포트와 수신지 포트
   2. 순서 번호: 세그먼트의 순서 보장을 위해 첫 바이트에 부여되는 번호. 초기 순서 번호 + 송신한 바이트 수
   3. 확인 응답 번호: 수신 호스트가 보낸 응답. 다음으로 수신하길 바라는 번호가 쓰여있다. ACK 플래그를 1로 설정한 뒤 '수신한 순서 번호 + 1'로 설정해서 응답한다.
   4. 제어 비트: 플래그 비트라고도 하며 현재 세그먼터에 대한 부가정보를 나타낸다. 총 8비트에 ACK(세그먼트 승인), SYN(연결 수립), FIN(연결 종류)비트가 1비트씩 있다.
   5. 윈도우: 한 번에 수신하고자 하는 데이터의 양
4. 통신 단계: 1. 연결 수립. 2. 데이터 송수신. 3. 연결 종료
#### TCP 통신 단계 1 - 연결 수립
three-way handshake를 거친다. 연결 후엔 데이터를 전송을 위해 ACK 세그먼트가 사용된다.
1. A \-> B (연결합니다): SYN 세그먼트. 호스트 A의 초기 순서 번호와 1인 SYN 비트를 보낸다.
2. A \<- B (확인했습니다. 연결 시작해요): SYN + ACK 세그먼트. B의 초기 순서 번호, A의 세그먼트에 대한 확인 응답 반호, 1인 SYN, ACK 비트를 보낸다.
3. A \-> B (확인했습니다): ACK 세그먼트. A의 다음 순서 번호, B의 세그먼트에 대한 확인 응답 번호, 1인 ACK 비트를 보낸다.
#### TCP 통신 단계 2 - 데이터 송수신
1. 오류 제어: 재전송 기법
   1. 송신 호스트의 재전송 상황: 체크섬은 훼손 여부를 수신 호스트에게 알려준다. 재전송을 하려면 송신 호스트가 자신이 보낸 세그먼트의 문제를 감지해야 한다. 아래의 경우 오류를 감지하고 재전송을 하게 된다.
      1. 중복된 ACK 세그먼트를 수신했을 때: A가 n+1을 보냈는데 누락되어 B가 못 받았다면, n+1을 보내달란 요청을 A에게 또 보내게 된다.
      2. 타임아웃이 발생했을 때: 재전송 타이머의 카운트 다운이 끝날 때까지 ACK 세그먼트가 오지 않는 타밈아웃이 되면 재전송한다.
   2. 재전송 기법 ARQ(Automatic Repeat Request, 자동 재전송 요구): 수신 호스트의 답변(ACK)과 타임아웃을 토대로 문제를 진단하고 재전송하여 신뢰성을 확보하는 방법
      1. Stop-and-Wait ARQ: 제대로 전달했음을 확인하기 전까지 새로운 메시지를 보내지 않는 방식. 세그먼트를 하나씩 보내서 효율이 낮다.
      2. Go-Back-N ARQ: 파이프라이닝을 이용해 여러 세그먼트를 전송하고 잘못된 전송된 세그먼트가 있다면 해당 세그먼트부터 전부 다시 전송하는 방식. 제대로 받으면 확인 응답을 하는데 n+2에 문제가 있다면 수신 호스트가 n+2 이후 세그먼트까지 다 폐기한다. 그러면 송신 호스트에 n+2 이후 모든 세그먼트에 타임아웃이 발생하여 재전송한다. 
      3. Selective Repeat ARQ: 수신 호스트가 성공한 수신 세그먼트에 대해 개별적으로 확인 응답을 하여, 누락된 세그먼트만 개별적으로 재전송할 수 있게 하는 방식. 오늘날 대부분의 호스트는 2번과 3번을 지원한다.
2. 흐름 제어: 슬라이딩 윈도우
   1. 문제 상황: 수신 호스트가 처리할 수 있는 양보다 더 많이 세그먼트가 전송되는 상황이다. 수신된 세그먼트는 애플리케이션에 읽히기 전에 수신 버퍼에 임시로 저장되는데 수신 버퍼의 크기보다 많은 데이터를 전송받으면 일부 세그먼트를 처리하지 못하는 버퍼 오버플로가 발생할 수 있다.
   2. 해결 방법: 수신 호스트의 슬라이딩 윈도우를 사용한다. 윈도우는 송신 호스트가 파이프라이닝 할 수 있는 최대량이다. 수신 호스트가 윈도우 필드로 보낸 값은 윈도우의 크기가 된다. 수신 호스트가 확인 응답을 할 때마다 수신 윈도우를 한칸 움직여 슬라이딩시킨다. 이후 송신 윈도우는 수신 윈도우에 맞춰서 이동한다.
3. 혼잡 제어
   1. 문제 상황: 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 위험이 있는 상황
   2. 혼잡 윈도우: 흐름 제어의 주체가 수신 호스트라면 혼잡 제어의 주체는 송신 호스트다. 송신 호스트가 직접 혼잡도를 계산하여 혼잡 윈도우congestion window를 설정한다.
   3. 혼잡 제어 알고리즘: 혼잡 윈도우의 크기를 정하는 알고리즘
      1. AIMD: 혼잡이 감지되지 않는다면 RTT(전송 후 답변까지의 시간)마다 혼잡 윈도우를 1식 증가시키고. 혼잡이 감지된다면 절반으로 떨어뜨리는 알고리즘. 합으로 증가, 곱으로 감소
      2. 느린 시작 알고리즘: 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식. 즉, 초기엔 2배씩 지수적으로 증가해 초기 전송 속도를 확보할 수 있다. 
      3. 혼잡 회피 알고리즘: RTT마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘. 혼잡 윈도우 크기가 선형적으로 증가한다.
      4. 빠른 회복 알고리즘: 세 번의 중복된 ACK 세그먼트를 수신했을 때, 느린 시작을 건너 띄고 빠른 회피를 수행하는 알고리즘. 빠르게 전송률을 회복하기 위한 알고리즘

      | 상황 분류 | 방법 |
      | -------- | ---- |
      | 타임아웃 발생 | 혼잡 윈도우 값은 1로, 느린 시작 임계치는 혼잡 시점의 혼잡 윈도우 값의 절반으로 초기화 후 느린 시작 알고리즘 재개 |
      | 혼잡 윈도우 >= 느린 시작 임계치 호과 | 임계치를 넘어선 후부터는 느린 시작을 종료하고 혼잡 윈도우를 절반으로 초기화한 후 회피 혼잡 알고리즘 수행. 혼잡을 피하기 위해 천천히 증가시키는 것 |
      | 세 번의 중복 ACK 발생 | 빠른 재전송 후 빠른 회복 알고리즘 수행 | 
      
      5. ECN 명시적 혼잡 알림: 라우터에서 혼잡을 감지하고 헤더의 서비스 필드에 ECN 비트를 통해 수신 호스트에서 혼잡 감지를 알려서 송신 호스트가 알 수 있게 하는 방식. 송신 호스트 혼자 오류가 발생하고나서야 제어하는 방식과 다르게 라우터의 도움을 받아 더 빠르게 감지할 수 있다.

#### TCP 통신 단계 3 - 연결 종료
1. A \-> B (연결 끊을게요): FIN 세그먼트. 1인 FIN 비트
2. A \<- B (확인했습니다): ACK 세그먼트. A가 전송한 세그먼트에 대한 확인 응답 번호와 1인 ACK 비트
3. A \<- B (이제 연결 끊어요): FIN 세그먼트. 1인 FIN 비트
4. A \-> B (확인했습니다): ACK 세그먼트. B가 전송한 세그먼트에 대한 확인 응답 번호와 1인 ACK 비트
#### TCP 상태
연결형, 신뢰성을 위해 다양한 '상태'를 유지한다. stateful protocol이다.
| 상태 분류 | 주요 상태 |
| -------- | -------- |
| 연결이 수립되지 않은 상태 | CLOSED, LISTEN |
| 연결 수립 상태 | SYN-SENT, SYN-RECEIVED, ESTABLISHED |
| 연결 종료 상태 | FIN-WAIT-1, CLOSE-WAIT, FIN-WAIT-2, LAST-ACK, TIME-WAIT, CLOSING |

### 4-3. UDP(User Datagram Protocol)
1. 개요: 신뢰성은 떨어지지만 비교적 따른 연결이 가능한 비연결형 프로토콜. 연결 수립, 제어도 없고 상태도 없기 때문에 stateless protocol이다. 스트리밍 서비스, 인터넷 전화에 쓰인다.
2. UDP 데이터그램
   1. 송신지 포트와 수신지 포트
   2. 길이: 헤더를 포함한 데이터그램의 바이트
   3. 체크섬: 오류가 발생했는지 점검하는 필드. 훼손 여부를 판단하는 것이지, 수신지까지 잘 도달했는지를 보는 신뢰성과 무관하다.

## 5. 응용 계층

### 5-1. DNS와 자원
#### 도메인 네임과 네임 서버
1. 도메인 네임: 호스트의 IP 주소와 대응되는 문자열 형태의 호스트 특정 정보. IP 주소만으로 특정하는 것보다 간편하다. 점(.)을 기준으로 계층적으로 분류된다. www(3단계 도메인).example(2단계 도메인).com(최상위도메인, TLD).(루트 도메인)
2. 네임 서버(DNS 서버): 도메인 네임과 IP 주소가 매핑되어 있는 서버
3. DNS(Domain Name System): 도메인 네임 관리 체계. 도메인 네임와 네임 서버는 모두 계층적인 구조를 가지는데 이들에 대한 관리 체계이자 프로토콜
#### 계층적 네임 서버
1. resolving: 도메인 이름으로 IP 주소를 알아내는 것. 네임 서버들에게 물어봐서 답을 얻는다. 방법으로는 최종적으로 처음에 물어본 루트 네임 서버가 알려주는 재귀적 질의와, 계층별로 클라이언트가 질의하면서 최종적으로 책임 네임 서버가 알려주는 반복적 질의가 있다. 실제로는 DNS 캐시에 저장해서 바로 답한다.
2. 로컬 네임 서버: 클라이언트와 맞닿아 있는 네임 서버. 가장 먼저 찾게 되는 서버. 클라이언트가 주소를 알고 있어야 한다. ISP에서 할당해주거나 구글의 8.8.8.8, 클라우드 플레어의 1.1.1.1 등의 공개 DNS 서버를 이용할 수 있다. 클라이언트가 물으면 로컬 네임 서버가 찾으려는 특정 도메인의 IP 주소를 알려준다.
3. 루트 네임 서버: 루트 도메인을 관장하는 네임 서버. 로컬 네임 서버가 모른다면 루트 네임 서버에게 해당 도메인 네임을 질의하게 된다. 최상위의 네임 서버이다.
4. TLD 네임 서버: 루트 아래 TLD를 관리하는 네임 서버. TLD의 하위 도메인 네임을 관리하는 네임 서버 주소를 반환할 수 있다. 물론 그 하위 네임 서버 역시 그보다 하위 네임 서버 주소를 반환할 수 있다.
5. 책임 네임 서버: 특정 도메인 영역을 관리하는 네임 서버. 자신이 관리하는 도메인 영역의 질의에 대해서 다른 네임 서버에 떠넘기지 않고 곧바로 답할 수 있는 네임 서버. 즉, 로컬 네임 서버가 최종적으로 질의하는 네임 서버
#### 자원을 식별하는 URI
1. 자원: 네트워크상의 메시지를 통해 주고받는 대상을 의미한다.
2. URI(Uniform Resource Identifier): 이 자원을 식별하는 정보, 자원을 식별하는 통일된 방식
   1. URL: 위치 기반 식별자. https:[scheme, 자원접근방법]//www.example.com:8042[authority, 호스트 특정 정보]/over/there[path, 자원이 위치한 경로]?name=ferret[query, 쿼리 파라미터]#nose[fragment, 자원의 한 조각을 가리키는 정보]
   2. URN: 이름 기반 식별자. 자원의 위치와 무관하게 식별할 수 있다. urn:isbn:04514505023 (ISBN이 04514505023인 도서)
#### DNS 자원 레코드
네임 서버가 저장하는 정보. 레코드는 A(도메인 네임과 IPv4 주소와의 대응), AAAA(도메인 네임과 IPv6 주소와의 대응), CNAME(별칭), NS(IP주소를 찾는 네임 서버), MX(연동 메일 서버) 등이 있다.

### 5-2. HTTP
응용 계층에서 정보를 주고 받을 때 쓰는 대표적인 프로토콜이다. 웹 세상의 기반을 이루고 중요한 역할을 한다.
#### HTTP의 특성
1. 요청-응답 기반 프로토콜: HTTP는 클라이언트-구조 기반의 요청-응답 프로토콜이다. 요청하고 응답을 받는 식으로 이루어진다.
2. 미디어 독립적 프로토콜: HTTP는 자원을 주고받는 수단(인터페이스)의 역할만을 하기 때문에 자원의 특성과 무관하다. 다양한 종류의 자원을 주고받을 수 있다. 자원의 종류를 미디어 타입이라고 한다. type/subtype:parameter=value(image/gif, application/json, text/html:charset=UTF-8)의 형식으로 나타낸다.
3. Stateless 프로토콜: 서버가 클라이언트의 상태를 기억하지 않는다. 모든 HTTP 요청은 독립적이기 때문에 같은 요청을 여러번 해도 다 다른 요청으로 받아들인다. 특정 클라이언트가 특정 서버에 종속되지 않기 때문에 언제든지 대체 가능해서 확장성과 견고성을 가진다.
4. 지속 연결 프로토콜: HTTP는 기본적으로 TCP 상에서 작동한다. HTTP1.0은 요청마다 TCP 연결을 새로 수립하는 비지속 연결이었지만, 1.1부터 지속 연결을 제공한다.
#### HTTP 발전
HTTP/0.9(GET) -> HTTP/1.0(HEAD, POST) -> HTTP/1.1(지속 연결, 파이프라이닝) -> HTTP/2.0(헤더 압축, 바이너리 테이터 송수신, 서버 푸시, 멀티 플렉싱(HOL 블로킹 완화)) -> HTTP/3.0(UDP,QUIC 기반 동작)
#### HTTP 메시지 구조
1. 시작 라인start line: HTTP 요청 메시지일 경우 요청 라인, 응답 메시지일 경우 상태 라인이 된다.
   1. 요청 라인: `메서드 요청대상(URI 하위 경로) HTTP버전` `GET /hello?q=world HTTP/1.1`
   2. 상태 라인: `HTTP버전 상태코드 이유구문` `HTTP/1.1 404 Not Found`
2. 필드 라인: 헤더 이름과 헤더 값으로 구성된 여러 개의 헤더가 명시된다.
3. 메시지 본문: 본문은 선택적이다. JSON이나 HTML로 작성된다.
#### 시작 라인
1. HTTP 메서드
   | HTTP 메서드 | 설명 |
   | ----- | ----- |
   | GET | 자원 습득 |
   | HEAD | 헤더만 습득 |
   | POST | 서버에게 작업 처리 요청 |
   | PUT | 자원 대체 |
   | PATCH | 자원 수정 |
   | DELETE | 자원 삭제 |
   | CONNECT | 자원에 대한 양방향 연결 시작 |
   | OPTIONS | 가능한 메서드 등 통신 옵션 확인 |
   | TRACE | 자원에 대한 루프백 테스트 수행 |
2. 상태 코드
   | 상태 코드 | 설명 |
   | ----------- | ----- |
   | 100번대 | 정보성 |
   | 200번대 | 성공. 200(OK), 201(Created), 202(Accepted), 204(No Content) |
   | 300번대 | 리다이렉션. 301(Moved Permanently), 308(Permanent Redirect), 302(Found), 303(See Other), 307(Temporary Redirect), 304(Not Modified) |
   | 400번대 | 클라이언트 에러. 400(Bad Request), 401(Unauthorized), 403(Forbidden), 404(Not Found), 405(Method Not Allowed) |
   | 500번대 | 서버 에러. 500(Internal Server Error), 502(Bad Gateway), 503(Service Unavailable) |
#### 필드 라인(HTTP 헤더)
1. 요청 시 활용되는 HTTP 헤더
   1. Host: 요청을 보낼 호스트를 나타내는 헤더
   2. User-Agent: HTTP 요청을 시작하는 클라이언트 프로그램 관련 정보. 운영체제, 브라우저 종류 및 버전, 렌더링 엔진 등
   3. Referer: 클라이언트가 요청을 보낼 때 머무르고 있던 URL. 초기 개발 당시 오타로 Referrer이 아닌 Referer이다.
   4. Authorization: 클라이언트 인증 정보를 담는 헤더
2. 응답 시 활용되는 HTTP 헤더
   1. Server: 서버 측의 소프트웨어오 관련된 정보를 명시하는 헤더
   2. Allow: 클라이언트에게 허용된 HTTP 메서드 목록을 알려주는 헤더
   3. Retry-After: 상태 코드 503(현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음)과 함께 사용되는 헤더. 사용할 수 있는 날짜를 명시한다.
   4. Location: 클라이언트에게 자원의 위치를 알려주기 위해 사용하는 헤더. 주로 리다이렉션이나 새로운 자원이 생성되었을 때 쓴다.
   5. WWW-Authenticate: 상태 코드 401과 함께 사용되는 헤더. 자원에 접근하기 위한 인증 방식을 설명해준다. Authorization 헤더와 WWW-Authenticate 헤더를 통해 HTTP 인증을 수행한다.
      1. 클라이언트 \-> 서버: GET 요청
      2. 클라이언트 \<- 서버: 401과 함께 WWW-Authenticate로 인증 방식 응답
      3. 사용자 \-> 클라이언트: 인증 정보(ID, PW) 입력
      4. 클라이언트 \-> 서버: ID:PW를 Base64 인코딩한 값을 인증 정보로 삼은 Authorization 헤더와 함께 GET 요청
      5. 클라이언트 \<- 서버: 인증 정보 확인 후 유효하면 200, 아니면 401 응답
3. 요청과 응답 모두에서 활용되는 HTTP 헤더
   1. Date: 메시지가 생성된 날짜와 시각
   2. Connection: 클라이언트의 요청과 응답 간의 연결 방식 설정. keep-alive면 지속 연결, close면 종료
   3. Content-Length: 본문의 바이트 단위 크기
   4. Content-Type, Content-Language(언어코드-국가코드, en-US, ko-KR), Content-Encoding: 메시지 본문의 표현 방식을 설명하는 헤더. 표현 헤더의 일종으로 불린다.

### 5-3. HTTP 기반 기술
#### 캐시
1. 개요: 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술 혹은 저장된 데이터. 웹 브라우저에 저장된 개인 전용 캐시나 클라이언트나 서버 사이 중간 서버에 저장되는 공용 캐시가 있다.
2. 캐시 신선도cache freshness: 캐시된 사본 데이터와 원본 데이터의 유사한 정보. 사본을 저장하기 때문에 이후에 원본 데이터가 변경된다면 캐시의 내용과 다를 수 있다. 캐시 신선도를 유지하기 위해 캐시의 유효 기간을 Expoires 헤더에 날짜를 쓰거나 Cache-Control 헤더의 max-age 값에 초를 넣어서 설정한다. 
3. 신선도 재검사: 유효 기간이 지났을 때 신선한지 재검사하여 신선하지 않다면 새 자원을 요청한다.
   1. 날짜 기반: If-Modified-Since 헤더를 통해 특정 시점 이후로 원본 데이터에 변경이 있었는지 검사한다. 서버는 자원이 변경되었다면 200, 변경되지 않았다면 Last-Modified 헤더에 날짜와 함께 304, 삭제되었다면 404를 반환한다.
   2. 엔티티 태그Etag 기반: 자원의 버전을 식별하기 위한 Etag를 통해서 유의미한 변경으로 버전 변경이 되었는지 검사한다.
#### 쿠키
HTTP의 무상태성을 보완하기 위한 서버에서 생성되어 클라이언트 측에 저장되는 데이터이다. 서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 보관했다가 동일한 서버에 요청을 보낼 때 쿠키를 포함해서 보낸다. 추가로 세션 아이디를 같이 보내기 때문에 세션 인증을 통해서 추가적인 인증 과정은 생략할 수 있다.
1. 응답 메시지: `Set-Cookie: name=min Set-Cookie: name=min; 속성1 Set-Cookie: name=min; domain=exam.com Set-Cookie: name=min; path=/lecture`
2. 요청 메시지: `Cookie: 이름=값; 이름-값;`
3. 보안: Secure 속성은 HTTPS 프로토콜일 경우만 전송하게 해준다. HTTPOnly는 HTTP 송수신을 통해서만 쿠키를 이용하도록 제한한다. HTTP가 아닌 스크립트로 접근하고 변조하지 못하게 해준다.
#### 웹 스토리지
웹 브라우저 내의 저장 공간이다. 로컬 스토리지는 영구적으로 저장된다. 세션 스토리지는 세션이 유지되는(브라우저가 열려있는) 동안 유지된다.
#### 콘텐츠 협상과 표현
1. 콘텐츠 협상content negotiation: 같은 URI에 대해 가장 적합한 자원의 형태를 제공하는 메커니즘. 영어로 요청하면 영어로, 한국어로 요청하면 한국어로 된 형태를 제공한다.
2. 표현representation: 송수신 가능한 자원의 형태. 즉, 컨텐츠 협상은 가장 적합한 표현을 제공한다. 우리가 GET 요청을 하면 정확히는 '자원'을 습득하는 게 아니라 '자원에 대해 현재 선택된 표현'을 습득한다고 할 수 있다.
3. 헤더: Accept, Accept-Language, Accept-Charset 등의 헤더가 쓰인다. q 값으로 선호도의 우선순위도 설정할 수 있다. `Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7`

## 6. 실습으로 복습하는 네트워크
### 6-1. 와이어샤크 설치 및 사용법
### 6-2. 와이어샤크를 통한 프로토콜 분석
&ensp;

## 7. 네트워크 심화

### 7-1. 안정성을 위한 기술
#### 가용성
네트워크의 안정성을 나타내는 수치. 안정성은 특정 기능을 언제든 균일한 성능으로 수행할 수 있는 특성을 말한다. 가옹성이 높다면 고가용성(HA, High Availability)이라고 한다. 가용성 = 업타밍 / (업타밍 + 다운타임). 안정적 시스템은 파이즈 나인즈(가용성 99.999%)를 목표로 한다. 이상적으로 모든 다운타임 발생 원일을 찾고 해결하는 건 불가능하기 때문에 문제가 발생하더라도 기능할 수 있는 결함 감내fault tolerance가 중요하다.
#### 이중화/다중화
문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상(단일 장애점)을 이중으로 두어 백업을 마련하는 기술이다. 액티브/스탠바이의 경우 하나를 대기시키고, 액티브/액티브의 경우 둘 다 가동 상태로 놓는다. 여러 개로 확장하면 다중화가 된다. 여러 개의 NIC를 하나의 NIC처럼 보이게 하는 티밍 혹은 본딩도 그 예시다.
#### 로드 밸런싱 load balancing
특정 서버에 트래픽이 몰리지 않도록 분배하는 기술. 로드 밸런서가 수행하게 된다. 로드 밸런서는 주기적으로 서버들에게 문제가 없는지 물어보는 헬스 체크health check를 한다. HAProxy, Envoy 등이 있다. Nginx에도 이 기능이 있다. 밸런싱 알고리즘으로 주로 가중치 라운드 로빈 알고리즘이나 가중치 최소 연결 알고리즘을 쓴다.
#### 프록시
1. 오리진 서버: 지원을 생성하고 클라이언트에게 권한 있는 응답을 보낼 수 있는 HTTP 서버
2. 중간 서버: 클라이언트와 오리진 서버 사이의 중간 서버. 프록시나 게이트웨이 등이 있다.
3. 프록시(포워드 프록시): 클라이어트가 선택한 메시지 전달 대리자. 주로 캐시 저장, 클라이언트 암호화 및 접근 제한 기능 등을 제공한다.
4. 게이트웨이(리버스 프록시): 아웃바운드 연결(클라이언트를 향하는 연결)에 대해선 오리진 서버 역할을 하지만, 수신된 요청을 반환하여 다른 인바운트 서버에게 전달하는 중개자. 즉, 클라이언트에겐 오리진 서버처럼 보인다.

### 7-2. 안정성을 위한 기술
#### 암호
1. 대칭 키 암호화symmetric key cryptography: 암호화와 복호화에 동일한 키를 사용하는 방식. 송신자와 수신자와 모두 동일한 키를 쓴다. 키를 안전하게 전달하기 어렵다는 단점이 있다.
2. 공개 키 암호화public key cryptography: 암호화와 복호화에 다른 키를 사용하는 방식. 누구나에게 공개되는 공개 키로 암호화하고 개인 키로 복호화한다. 공개 키와 개인 키는 서로 유추할 수 없다. A -> B 요청 시 A가 B의 공개 키를 요청하고, B는 공개 키를 전달하고, A는 받은 공개 키로 암호화해서 보내면 B는 개인 키로 복호화한다. 암호화, 복호화가 대칭 키 대응
3. 세션 키session key: 대칭 키 암호화와 공개 키 암호화의 장점을 혼합한 방식. 공개 키로 대칭 키를 암호화하고 개인 키로 대칭 키를 복호화해서, 공개 키 암호화보다 빠르면서도 안전하게 수행할 수 있다.  
#### 인증서
1. 개요: 일반적으로 공개 키 인증서를 가리킨다. 공개 키와 공개 키의 유효성을 검증한다. 제3의 인증 기관들에서 발급한다. 클라이언트는 인증서의 서명 값을 바탕으로 인증서를 검증한다.
2. 디지털 서명digital signature: 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차
   1. 서명 값은 인증서 내용에 대한 해시 값을 CA의 개인 키로 암호화하는 방식으로 만들어진다.
   2. 이는 다시 CA의 공개 키로 복호화할 수 있기 때문에, 클라이언트는 복호화해서 얻는 인증서 내용에 대한 해시값을 얻는다.
   3. 클라이언트는 직접 인증서 데이터에 대해서 해시값을 구한다.
   4. 2와 3을 비교해서 같다면 CA의 개인 키로 만들어진 게 맞다(인증서를 신뢰할 수 있다)고 알 수 있다. 
#### HTTPS: SSL와 TLS
1. SSL/TLS: SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 인증과 암호화를 수행하는 프로토콜이다. TLS는 SSL을 계승했다.
2. HTTPS: SSL/TLS를 사용하는 대표적인 프로토콜이다.
   1. TCP three way handshake(SYN -> SYN+ACK -> ACK)
   2. TLS handshake(ClientHello(암호화 이전 맞춰야 할 정보들, 암호 스위트) -> ServerHello(제시된 정보 선택, 암호화에 사용할 키 교환, 인증서, 디지털 서명, Finished) -> Finished)
   3. 암호화된 메시지 송수신

### 7-3. 무선 네트워크
#### 전파와 주파수
1. 전파: 3kHz~3THz 사이의 진동수를 갖는 전자기파
2. 주파수 대역: 수많은 전파들이 혼재되어 있기 때문에 다른 전파 신호를 구분하기 위해 정해진 범위. 대한민국 주파수 분배도표 참조
#### 와이파이와 802.11
1. IEEE 802.3: 오늘날 LAN 환경에서의 유선통신 표준
2. IEEE 802.11: 오늘날 LAN 환경에서의 무선통신 표준. 2.4GHz, 5GHz 대역을 사용한다. 그래서 와이파이 이름에 2.4G나 5G가 붙는 것이다. 버전(802.11a, 802.11g 등)에 따라서 주파수 대역과 전송 속도가 다르다.
3. 와이파이: IEEE 802.11 표준을 따르는 무선 LAN 기술. 본래는 와이파이 얼라이언스Wi-Fi Alliance라는 비영리단체의 브랜드 이름이다. 그래서 Wi-Fi는 인증 역할도 한다. 보면 Wi-Fi 인증 로고가 다 붙어있다.
4. 채널: 같은 주파수 대역이라도 별개의 무선 네트워크가 존재하기 때문에 이를 구분하기 위한 하위 주파수 대역. 이 채널 대역에서 통신이 이루어진다. 간섭이 적도록 좀 떨어진 채널로 설정하는 것이 좋다.
#### AP와 서비스 셋
1. AP(Access Point): 무선 통신 기기들을 연결하여 무선 네트워크를 구성하는 무선 네트워크 장치. 무선 공유기도 이에 해당한다. 무선 LAN 기기들은 AP를 경유해 인터넷을 접속하고 메시지를 주고받는다. AP를 경유해 ㅇ루어지는 통신 방식을 인프라스트럭처 모드infrastructure mode라고 한다.
2. 서비스 셋: AP를 중심으로 연결되어 무선 네트워크 형성하는 여러 장치들의 집합. 같은 서비스 셋이면 같은 무선 네트워크에 속한다고 볼 수 있다. SSID(Service Set Indentifier, 서비스 셋 식별자)를 통해 무선 네트워크를 구분한다. SSID는 무선 네트워크를 지칭하는 고유한 이름, 우리가 보는 와이파이의 이름이 된다.
3. 비컨 프레임beacon frame: 자신을 알리기 위해 주기적을 날리는 브로드캐스트 메시지. AP는 선이 없기 때문에 외부에 자신의 존재를 지속적으로 알려야만 하기 때문이다. 와이파이 목록이 뜨는 건 비컨 프레임을 받았기 때문이다,